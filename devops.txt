
⸻

Q1) “Current state” confirmation (AIR Appx 5)
	•	Answer: FRFS is predominantly on-prem today with targeted workloads already in AWS landing zones (Commercial & GovCloud) and a staged migration path via ACC/LZ onboarding. Our IaC and tagging standards are already in place and used for anything that lands in AWS.

Q2) Terraform state management & drift
	•	Answer: Remote state in S3 + DynamoDB locking per account/region/env/workload key. Buckets are versioned, encrypted (SSE-KMS), private, and lifecycle-managed. Only CI runners with least-privilege can read/write.
	•	Drift mitigation: every PR runs terraform plan -detailed-exitcode; plans are stored as artifacts; we require an approval gate before apply. Periodic plan jobs in non-prod also catch config drift.

Q3) Automation ratio (IaC vs. manual)
	•	Answer: >90% of infrastructure is built via reusable CES IaC modules (VPC, IAM, ALB, API GW, Lambda, DynamoDB, etc.). Manual steps are limited to exception cases (e.g., initial account vending/control baselines) and are documented with a path to codify when feasible.

Q4) Tagging usage & automation
	•	Answer: We enforce a mandatory tag set (e.g., Application, Owner, CostCenter, Environment, DataClassification, BusinessUnit) at module inputs so resources are created with tags by default.
	•	Automation with tags: cost & utilization reports (CUR/Athena/QuickSight), environment scoping, resource compliance checks, and cleanup targeting. CES modules won’t create without required tags; CI fails if tags are missing.

Q5) Further automation for ACC migrations (provisioning & “rehydration”)
	•	Answer: Yes. ACC migrations use golden CES modules and the standard GitLab pipeline so environments are reproducible (“rehydratable”) from code. Same pipeline promotes Dev→Test→Prod with plan artifacts, approvals, and a guarded destroy stage.

Q6) Enforcement specifics (tagging & compliance)
	•	Answer: Pre-commit/CI policy checks (Checkov/tfsec) block merge/apply if tags or controls are missing. AWS Config conformance rules and SCPs with condition keys (e.g., deny creates when required tag keys are absent) keep console drift out. Where used, Tag Policies enforce allowed values. We also have periodic reports to reconcile stragglers.

Q7) Terraform edition (OSS vs Cloud)
	•	Answer: We’re on Terraform OSS executed by GitLab runners. We assessed Terraform Cloud but stayed OSS due to security boundary, cost, and Fed constraints; our S3/DDB backend + pipeline gates meet our needs for state, RBAC, and auditability.

Q8) Policy-as-Code tools
	•	Answer: Yes. In CI we run Checkov (and tfsec/SAST) on every change. In AWS we lean on Control Tower guardrails/SCPs, AWS Config, and selective Tag Policies. Net effect: policy at plan time and runtime.

⸻

How our CES pipeline works (talk track)
	•	Stages (Prepare → Build → Apply/Destroy):
	•	Prepare: build_debug, build_env, build_aws, secret detection, IaC SAST (tfsec/Checkov).
	•	Protect: protect_env enforces allowed env/account/region combos.
	•	Terraform: tf_init → tf_plan (artifacted JSON) → manual approval → tf_apply. tf_destroy is feature-flagged and separately gated.
	•	Creds: short-lived IAM creds written to ephemeral files for runners, least-privileged per env (seen in the build_aws step).
	•	Outputs: plan/apply JSON artifacts, logged and auditable (you can point to the Confluence “Terraform Pipeline” diagram in your screenshots).

Naming & tagging standard (one-liners)
	•	Naming: <env>-<service>-<component>-<purpose>; consistent across regions/accounts so state keys, dashboards, and alerts align.
	•	Tags (minimum): Application, Owner, Environment, CostCenter, BusinessUnit, DataClassification, and service-specific tags where required (backup/retention, RTO/RPO).
	•	Enforcement: tags are required module variables; CI/policy checks + SCP/Config keep them consistent post-deploy.

If they press on “rehydration” details
	•	Rehydrate = redeploy from code: new account/region can be stood up by re-running the same pipeline with only variables changed (account alias, region, env). State backends are created by bootstrap modules, then workload modules apply cleanly. No snowflakes.

If they ask about manual consoles or exceptions
	•	Answer: Console changes are discouraged; where truly required, we (1) record change, (2) add it to IaC, and (3) reconcile via plan to remove drift. SCPs & IAM boundary policies restrict high-risk console operations.
